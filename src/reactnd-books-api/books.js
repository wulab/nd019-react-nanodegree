require('isomorphic-fetch');
const ApiError = require('./api-error');
const queue = require('queue');

const invariant = require('invariant');
const clone = require('clone');

const apiKey = process.env.GOOGLE_BOOKS_API_KEY;

const LRU = require('lru-cache');
const cacheOptions = {
  max: 50000,
  length: function(n, key) {
    return n * 2 + key.length;
  },
  maxAge: 1000 * 60 * 60 * 24 * 7,
  stale: false
};
const lruCache = LRU(cacheOptions);

const searchWhitelistBase = [
  'PGR2AwAAQBAJ',
  'yDtCuFHXbAYC',
  'uu1mC6zWNTwC',
  'wrOQLV6xB-wC',
  'pD6arNyKyi8C',
  '1q_xAwAAQBAJ',
  '32haAAAAMAAJ',
  'Linux',
  'redux programming',
  'html',
  'Rowling',
  'King',
  'Shakespeare',
  'Tolstoy',
  'Austen',
  'Christie',
  'Cervantes',
  'Marquez',
  'Bhagat',
  'Singh',
  'Lahiri',
  'Desai',
  'Gandhi',
  'Hugo',
  'Dumas',
  'Camus',
  'Kafka',
  'Larsson',
  'Ibsen',
  'Homer',
  'Thrun',
  'Philosophy',
  'River',
  'Tale',
  'Ultimate',
  'Cook',
  'Learn',
  'Journey',
  'Make',
  'First',
  'Program',
  'Javascript',
  'Design',
  'Photography',
  'Negotiate',
  'Manage',
  'History',
  'Brief',
  'Time',
  'Everything',
  'Production',
  'Future',
  'Money',
  'Classics',
  'Education',
  'Football',
  'Swimming',
  'Cycling',
  'Cricket',
  'Baseball',
  'Games',
  'Basketball',
  'Drawing',
  'Painting',
  'Art',
  'Programming',
  'Development',
  'Astronomy',
  'React',
  'Redux',
  'Film',
  'History',
  'Mystery',
  'Fantasy',
  'Horror',
  'Science Fiction',
  'Business',
  'Finance',
  'Travel',
  'Literary Fiction',
  'Robotics',
  'Artificial Intelligence',
  'Android',
  'iOS',
  'Digital Marketing',
  'Virtual Reality',
  'Web Development',
  'Biography',
  'Poetry',
  'Comics',
  'Satire',
  'Drama',
  'Fitness'
];

let searchWhitelist; // Autogenerated on first usage

invariant(apiKey, 'Missing $GOOGLE_BOOKS_API_KEY environment variable');

const db = {};

const defaultData = {
  currentlyReading: ['PGR2AwAAQBAJ', 'yDtCuFHXbAYC'],
  wantToRead: ['uu1mC6zWNTwC', 'wrOQLV6xB-wC'],
  read: ['pD6arNyKyi8C', '1q_xAwAAQBAJ', '32haAAAAMAAJ']
};

const getData = token => {
  let data = db[token];

  if (data == null) {
    data = db[token] = clone(defaultData);
  }

  return data;
};

const getShelf = (token, bookId) => {
  const data = getData(token);
  const keys = Object.keys(data);
  return keys.find(key => data[key].includes(bookId)) || 'none';
};

const addShelf = token => book => {
  book.shelf = getShelf(token, book.id);
  lruCache.set(book.id, book); // store the book in the LRU cache for retrieval if ever needed by get() below
  return book;
};

const api = 'https://www.googleapis.com/books/v1';

const createBook = item =>
  Object.assign({}, item.volumeInfo, {
    id: item.id
  });

const get = (token, id) => {
  console.log('books: running get for id:', id);
  var book = lruCache.get(id);
  if (book) {
    console.log('books: got LRU cache hit for book id :', id);
    return Promise.resolve(book);
  }
  return {};
};

const getAll = token => {
  const data = getData(token);
  const bookIds = Object.keys(data).reduce(
    (memo, shelf) => memo.concat(data[shelf]),
    []
  );

  return Promise.all(bookIds.map(bookId => get(token, bookId)));
};

const update = (token, bookId, shelf) =>
  new Promise(resolve => {
    const book = lruCache.get(bookId);
    const data = getData(token);

    book.shelf = shelf;
    lruCache.set(bookId, book);

    Object.keys(data).forEach(s => {
      if (s === shelf) {
        if (!data[s].includes(bookId)) data[s].push(bookId);
      } else {
        data[s] = data[s].filter(id => id !== bookId);
      }
    });

    resolve(data);
  });

const search = (token, query, maxResults = 20) => {
  // First time run, fill out the search whitelist from the base words.
  if (searchWhitelist === undefined) {
    searchWhitelist = {};
    for (let word of searchWhitelistBase) {
      for (let j = 1; j <= word.length; ++j) {
        searchWhitelist[
          word.substring(0, j).toLowerCase()
        ] = word.toLowerCase();
      }
    }
  }
  let acceptableQuery = ''; // assume student did not choose something acceptable
  var loQuery = query.toLowerCase();
  for (let subWord in searchWhitelist) {
    // console.log('Checking subword', subWord, 'against', loQuery);
    if (loQuery === subWord) {
      acceptableQuery = searchWhitelist[subWord];
      break;
    }
  }

  // if query not in whitelist return standard query results e.g. trump
  const key = `${api}/volumes?key=${apiKey}&q=${encodeURIComponent(
    acceptableQuery
  )}&maxResults=${maxResults}&fields=items(id,volumeInfo)`;
  console.log(
    'books: running search query for : ',
    acceptableQuery,
    'key:',
    key
  );

  var books = lruCache.get(key);
  if (books) {
    console.log('books: got LRU cache hit for books @ :', key);
    return Promise.resolve(books);
  }

  return fetch(key)
    .then(res => {
      if (res.error) {
        throw new Error('Network error');
      } else {
        return res.json();
      }
    })
    .then(data => {
      // console.log('data:', JSON.stringify(data,null,2));
      if (data.error) {
        throw new ApiError(data.error.message);
      } else {
        return data.items.map(createBook);
      }
    })
    .then(books => {
      var booksMap = books.map(addShelf(token));
      lruCache.set(key, booksMap);
      return booksMap;
    })
    .catch(e => {
      //console.log('Caught error:',e);
      var errorObject;
      if (e.type && e.type === 'system') {
        errorObject = { error: 'network:' + e.message, items: [] };
        console.log('Network error, returning:', errorObject);
        return errorObject;
      } else if (e instanceof ApiError) {
        errorObject = { error: 'api:' + e.message, items: [] };
        console.log('API error, returning:', errorObject);
        return errorObject;
      }
    });
};

// Seed the LRU cache on startup.
const seedLruCache = function() {
  console.log('Seeding LRU cache for', searchWhitelistBase.length, 'terms.');
  var q = queue();
  var queueFuncFactory = function(token, word) {
    return function(cb) {
      search(token, word);
      cb();
    };
  };
  for (var wordIndex in searchWhitelistBase) {
    var word = searchWhitelistBase[wordIndex];
    var token = 'server';
    var qFunc = queueFuncFactory(token, word);
    console.log('Queueing seed job for term:', word);
    q.push(qFunc);
  }
  q.start(function(err) {
    console.log('All seeding jobs done');
  });
};
seedLruCache();

module.exports = {
  get,
  getAll,
  update,
  search
};
